#!/usr/bin/env perl 
#

use strict;
use warnings;
use DBI;
use Getopt::Long;
use Data::Dumper;

my $version = "2.0.0.alpha";


our (%mycnf, %mem, %opt, $dbh, %vars, %stats, %fsinfo, %cpu, %sys, %db, %f); 

GetOptions(
        \%opt, 'username=s', 'password=s', 'help', 'host=s', 'socket=s', 'update', 'csv', 'format',
);

$mycnf{host} = "127.0.0.1";

sub get_mycnf {
        # No user / pass was supplied
        if ( -r "/etc/psa/.psa.shadow" ) { # It's a Plesk box
                $mycnf{user} = "admin";
                open DOTPSA, "/etc/psa/.psa.shadow" or warn "Can't open the /etc/psa/.psa.shadow file. $!\n";
                $mycnf{pass} = <DOTPSA>;
                close DOTPSA;
                return;
        }
        open MYCNF, "$ENV{HOME}/.my.cnf" or warn "Can't open the .my.cnf file. $!\n"; # Last resort - check for ~/.my.cnf
        while(<MYCNF>) {
                if(/^(.+?)\s*=\s*"?(.+?)"?\s*$/) {
                        $mycnf{$1} = $2;
                }
        }
        $mycnf{pass} ||= $mycnf{password} if exists $mycnf{password};
        close MYCNF;
}


sub connect_db {
        my $dsn;
        if ($opt{socket}) {
                $dsn = "DBI:mysql:mysql_socket=$opt{socket}";
        } else {
                $dsn = "DBI:mysql:host=$mycnf{host}";
        }
        $dbh = DBI->connect($dsn, $mycnf{user}, $mycnf{pass}) or usage();
}

sub get_stats {
        my $query = $dbh->prepare("SHOW GLOBAL STATUS;");
        $query->execute();
        my @row;
        while(@row = $query->fetchrow_array()) { $stats{$row[0]} = $row[1];}
}

sub get_vars {
        my $query = $dbh->prepare("SHOW VARIABLES;");
        $query->execute();
        my @row;
        while(@row = $query->fetchrow_array()) { $vars{$row[0]} = $row[1]; }
        $vars{'table_cache'} = $vars{'table_open_cache'} if exists $vars{'table_open_cache'};
        unless (defined $vars{'skip_name_resolve'}) { $vars{'skip_name_resolve'} = "NULL";}
        unless (defined $vars{'slow_query_log'}) { $vars{'slow_query_log'} = "NULL";}
        unless (defined $vars{'slow_query_log_file'}) { $vars{'slow_query_log_file'} = "NULL";}
        $vars{'innodb_additional_mem_pool_size'} = exists $vars{'innodb_additional_mem_pool_size'} ? $vars{'innodb_additional_mem_pool_size'} : 0;
        $vars{'innodb_buffer_pool_size'} = exists $vars{'innodb_buffer_pool_size'} ? $vars{'innodb_buffer_pool_size'} : 0;
        $vars{'innodb_log_buffer_size'} = exists $vars{'innodb_log_buffer_size'} ? $vars{'innodb_log_buffer_size'} : 0;
}

sub short {
        # number, is it kilobytes?, decimal places
        my ($number, $kb, $d) = @_;
        my $n = 0;
        my $short;

        $d ||= 0;

        if($kb) { while ($number > 1023) { $number /= 1024; $n++; }; }
        else { while ($number > 999) { $number /= 1000; $n++; }; }

        $short = sprintf "%.${d}f%s", $number, ('','k','M','G','T')[$n];
        if($short =~ /^(.+)\.(00)$/) { return $1; } # 12.00 -> 12 but not 12.00k -> 12k

        return $short;
}

sub sec2time {
	my $uptime  = shift;
	my $seconds = $uptime % 60;
	my $minutes = int( ( $uptime % 3600 ) / 60 );
	my $hours   = int( ( $uptime % 86400 ) / (3600) );
	my $days    = int( $uptime / (86400) );
	my $uptimestring;
	if ( $days > 0 ) {
		$uptimestring = "${days}d ${hours}h ${minutes}m ${seconds}s";
	} elsif ( $hours > 0 ) {
		$uptimestring = "${hours}h ${minutes}m ${seconds}s";
	} elsif ( $minutes > 0 ) {
		$uptimestring = "${minutes}m ${seconds}s";
	} else {
		$uptimestring = "${seconds}s";
	}
	return $uptimestring;
}

sub percent {
        my($is, $of) = @_;
        return sprintf "%.0f", ($is * 100) / ($of ||= 1);
}

sub ordsuf ($) {
# package Lingua::EN::Numbers::Ordinate
	return 'th' if not(defined($_[0])) or not( 0 + $_[0] );
	my $n = abs($_[0]);  
	return 'th' unless $n == int($n);
	$n %= 100;
	return 'th' if $n == 11 or $n == 12 or $n == 13;
	$n %= 10;
	return 'st' if $n == 1; 
	return 'nd' if $n == 2;
	return 'rd' if $n == 3;
	return 'th';
}

sub get_memory_usage {
        open MEMINFO, "/proc/meminfo" or return;
        while( my $line = <MEMINFO>) {
                chomp($line);
                my ($memstat, $memvalue) = split (/:/, $line);
		$memvalue =~ s/^\s+(\d+)\s?\w*/$1/g;
                $mem{$memstat} = $memvalue;
        }
        close MEMINFO;
# MySQL
	$mem{InnoDBBufferPoolSize} = sprintf "%.0f",(((($mem{MemTotal} / 100) * 80) / 1024) / 1024);
        $mem{MySQLBase} = ($vars{'key_buffer_size'} + $vars{'query_cache_size'} + $vars{'innodb_buffer_pool_size'} + $vars{'innodb_additional_mem_pool_size'} + $vars{'innodb_log_buffer_size'});
        $mem{MySQLPerConnection} = ($vars{read_buffer_size} + $vars{read_rnd_buffer_size} + $vars{sort_buffer_size} + $vars{join_buffer_size} + $vars{binlog_cache_size} + $vars{thread_stack});
	$mem{MySQLPossibleMaxConnections} = int ((((($mem{MemTotal} * 1024) / 100) * 90) - $mem{MySQLBase}) / $mem{MySQLPerConnection});
        $mem{MySQLMaxConnectionConfigured} = ($mem{MySQLPerConnection} * $vars{max_connections});
        $mem{MySQLMaxConnectionUsed} = ($mem{MySQLPerConnection} * $stats{Max_used_connections});
        $mem{MySQLMaxConfigured} = short(($mem{MySQLBase} + $mem{MySQLMaxConnectionConfigured}), 1);
        $mem{MySQLMaxUsed} = short(($mem{MySQLBase} + $mem{MySQLMaxConnectionUsed}), 1);
	$mem{MySQLUsedPerc} = percent(($mem{MySQLMaxConnectionConfigured} + $mem{MySQLBase}), ($mem{MemTotal} * 1024));
	$mem{MySQLBase} = short($mem{MySQLBase});
	$mem{MySQLPerConnection} = short($mem{MySQLPerConnection});
# System
	$mem{MemFreePerc} = percent($mem{MemFree},$mem{MemTotal});
	$mem{MemTotal} = short(($mem{MemTotal} * 1024), 1);
	$mem{MemFree} = short(($mem{MemFree} * 1024), 1);
	$mem{Cached} = exists $mem{Cached} ? short(($mem{Cached} * 1014), 1) : "0";
        $mem{SwapUsed} = exists $mem{SwapTotal} ? short((($mem{SwapTotal} * 1024) - ($mem{SwapFree} *1024)), 1) : "0";
	$mem{SwapFreePerc} = exists $mem{SwapTotal} ? percent($mem{SwapFree},$mem{SwapTotal}) : "0";
	$mem{SwapTotal} = exists $mem{SwapTotal} ? short(($mem{SwapTotal} * 1024), 1) : "0";
	$mem{SwapFree} = exists $mem{SwapTotal} ? short(($mem{SwapFree} * 1024), 1) : "0";
}

sub get_disk_usage {
	my @df_out = `/bin/df -lh`;
	foreach (@df_out) {
		if ($_ =~ /\d\%/) {
			my ($line, $filesystem) = split (/% /, $_);
			chomp ($filesystem);
			my @fields = split(/\s+/, $line);
			$fsinfo{$filesystem}{TotalSize} = $fields[1];
			$fsinfo{$filesystem}{Used} = $fields[2];
			$fsinfo{$filesystem}{Available} = $fields[3];
			$fsinfo{$filesystem}{PercentUsed} = $fields[4];
	                if ($fsinfo{$filesystem}{PercentUsed} >= 90) {
	                        unless ($filesystem =~ /run/) { push @{$sys{DiskAlerts}}, "The '$filesystem' filesystem is $fsinfo{$filesystem}{PercentUsed}% used.\n";}
	                }

		}
	}
}

sub get_cpu_usage {
	my @lscpu = `lscpu`;
	foreach my $line (@lscpu) {
		chomp($line);
		$line =~ s/[()]//g;
		my ($name, $number) = split /:/, $line;	
		$name =~ s/([\w']+)/\u\L$1/g;
		$name =~ s/\s+//g;
		$number =~ s/^\s+//g;
		$cpu{$name} = $number;
	}
	$cpu{TotalCores} = ($cpu{CoresPerSocket} * $cpu{Sockets});
	$cpu{TotalThreads} = ($cpu{ThreadsPerCore} * $cpu{TotalCores});
	$cpu{Max15MinLoad} = ($cpu{Cpus} * 0.75);
	unless ( -d "/var/log/sa" ) { return;}
        opendir my $dir, "/var/log/sa" or return;
        my @sar_logs = readdir $dir;
        closedir $dir;
        foreach my $log(@sar_logs) {
                next if ($log =~ /sar/);
                next if ($log =~ /^\.\.?$/);
                $cpu{TotalSarLogs}++;
                my @daily_load_ave = `sar -f /var/log/sa/$log -q | egrep -v 'Linux|runq|Average'`;
                foreach my $ldav(@daily_load_ave) {
                        next if ($ldav =~ /^\s?$/);
                        my @fifteen_load_ave = split(' ', $ldav);
                        chomp(@fifteen_load_ave);
                        next unless (defined $fifteen_load_ave[5]);
			$cpu{LoadTotal} += $fifteen_load_ave[5];
			$cpu{LoadCount}++;
                        if ($fifteen_load_ave[5] >= $cpu{Max15MinLoad}) {
                                $cpu{LoadAverageOverCount}++;
                        }
                }
        }
	$cpu{LoadAve} = sprintf '%.0f%%', 100 * (($cpu{LoadTotal} / $cpu{Cpus}) / $cpu{LoadCount});
}

sub get_system_info {
        unless ( -e "/etc/redhat-release" ) { return; }
	$sys{Hostname} = `hostname`;
	$sys{OSVersion} = `cat /etc/redhat-release`;
	$sys{Date} = `date "+%B %Y"`;
	chomp($sys{Day} = `date "+%e"`);
	$sys{DaySuffix} = ordsuf($sys{Day});
        $sys{Date} = "$sys{Day}$sys{DaySuffix} $sys{Date}";
	@{$sys{IPAddresses}} = (`ip -o addr show up primary scope global` =~ /inet\s(\d+\.\d+\.\d+\.\d+)/g);
	$sys{MySQLUptime} = sec2time($stats{Uptime}); 
	($sys{LastKernelVersion}, $sys{LastUpdateTime}) = split (/ {2,}/, `rpm -q kernel --last | head -n1`);	
	$sys{LastUpdateTime} =~ s/\s+(AM|PM).*//g;
	($sys{UptimeSeconds} = `cat /proc/uptime`) =~ s/(^\d+?)\..*/$1/g;
	$sys{SystemUptime} = sec2time($sys{UptimeSeconds});
	($sys{TimeOfReboot} = time()) -= $sys{UptimeSeconds};
	$sys{TimeOfReboot} = localtime($sys{TimeOfReboot});
        my ($wday, $mon, $mday, $rtime, $year) = split(' ', $sys{TimeOfReboot});
        chomp($mday);
        if ($mday =~ /^\d$/) { $mday = "0$mday"; }
        $sys{TimeOfReboot} = "$wday $mday $mon $year $rtime";
        $sys{KernelInUse} = `uname -r`;
	$sys{LastKernelVersion} =~ s/kernel-//g;
	$sys{CP1Updates} = `rpm -q yum-p1mh-autoupdates`;
	$sys{CP1Updates} = $? >> 8;
	chomp($sys{MySQLPID} = `pidof mysqld`);
	@{$sys{ulimit}} = split (/\s+/,`grep "open files" /proc/$sys{MySQLPID}/limits`); 
	$sys{ulimit} = @{$sys{ulimit}}[4];
	$sys{MySQLOpenFiles} = `lsof -p $sys{MySQLPID} | wc -l`;
	chomp(%sys);
}

sub get_backup_info {
	@{$sys{RootCron}} = `crontab -l 2>/dev/null`;
        foreach(@{$sys{RootCron}}) {
		next if /^#/;
                if ($_ =~ /db|mysql|database|backup/) {
                        $sys{BackupCronFound} = "1";
                        chomp($_);
	                my @arr = split (/\s+/,$_);
        	        $arr[5]=join(" ",splice(@arr,5));
                	@{$sys{DaysOfWeek}} = ("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday", "Daily");
                	my ($min, $hour, $dom, $month, $dow, $command) = @arr;
                        if ($dow =~ /\d/) { $dow = $sys{DaysOfWeek}[$dow]; } else { $dow = $sys{DaysOfWeek}[8]; }
			if ($hour =~ /\//) { 
				my @entry = split(/\//, $hour); 
				$hour = "Every $entry[1] hours"; 
				push @{$sys{BackupCron}}, sprintf ("%-15s %-10s %-50s\n", $hour,"($dow)",$command);
				next;
			}
			push @{$sys{BackupCron}}, sprintf ("%02d:%02d %-10s %-50s\n",$hour,$min,"($dow)",$command);
                }
        }
	@{$sys{KnownBackupDirs}} = ('/backups', '/home/backups', '/var/lib/mysql/backups', '/var/backup/db', '/home/dbdumps');
	foreach(@{$sys{KnownBackupDirs}}) {
		if (-d $_) {
			$sys{BackupDirFound} = "1";
			chomp($_);
			push @{$sys{BackupDir}}, $_;
		}
	}
	if (-d "/opt/tivoli") { $sys{TivoliInstalled} = "1"; }
}

####### MySQL

sub query_db {
	my ($sql, $type) = @_;
	my $query = $dbh->prepare("$sql");
	$query->execute;
	while (my @out = $query->fetchrow_array()) {
                next unless ($out[0]);
		foreach (@out) {$_ = 'null' unless defined};
		@{$db{$type}{$out[0]}} = splice(@out,1); 
	}
}

sub get_database_info {
	# Databases
	my $sql = ("select table_schema, truncate(sum(data_length + index_length)/1024/1024,2) 
		    FROM information_schema.tables 
		    WHERE table_schema not in ('mysql', 'performance_schema', 'information_schema', 'sys') 
		    group by table_schema;");
	query_db($sql, 'database');

	# Tables - Engines
	$sql = ("SELECT engine,
                 count(*) as TABLES,
                 concat(round(sum(table_rows)/1000000,2),'M') `rows`,
                 concat(round(sum(data_length)/(1024*1024*1024),2),'G') DATA,
                 concat(round(sum(index_length)/(1024*1024*1024),2),'G') idx,
                 concat(round(sum(data_length+index_length) / (1024*1024*1024),2),'G') total_size,
                 round(sum(index_length)/sum(data_length),2) idxfrac
                 FROM information_schema.TABLES
                 WHERE table_schema not in
                 ('mysql', 'performance_schema', 'information_schema')
                 GROUP BY engine
                 ORDER BY sum(data_length+index_length) DESC LIMIT 10;");
	query_db($sql, 'tables');
	
	foreach my $engine (keys $db{tables}) {
		$db{TableCount} += $db{tables}{$engine}[0];
	}

	# Exit here if there are > 10000 tables as this can cause problems
	if ($db{TableCount} >= 10000) { return; }

	# Tables - Fragmentation
	$sql =	("SELECT table_schema, 
                  table_name, 
                  (data_free /1024/1024) AS FREE, 
                  engine FROM information_schema.tables 
                  WHERE table_schema  NOT IN ('information_schema', 'mysql') 
                  AND (data_free/1024/1024) > 50;");
	query_db($sql, 'frag');

	# Tables - No primary / unique keys
	$sql = ("SELECT t.table_schema,t.table_name 
		 FROM information_schema.tables t 
		 INNER JOIN information_schema.columns c on t.table_schema=c.table_schema and t.table_name=c.table_name 
		 and t.table_schema not in ('performance_schema','information_schema','mysql','sys') 
		 GROUP BY t.table_schema,t.table_name,t.engine HAVING sum(if(column_key in ('PRI','UNI'), 1,0)) =0 and t.engine IS NOT NULL;");
	query_db($sql, 'ukeys');
	
	# Tables - No index
	foreach my $dbname (keys $db{database}) {
		$sql = ("SELECT table_schema,table_name,table_collation,engine,table_rows FROM INFORMATION_SCHEMA.tables 
         		 WHERE table_schema = '$dbname' AND table_rows IS NOT NULL 
                	 AND table_name NOT IN ( SELECT table_name FROM ( SELECT table_name, index_name FROM information_schema.statistics WHERE table_schema = '$dbname' 
                	 GROUP BY table_name, index_name) tab_ind_cols group by table_name );");
		query_db($sql, 'noindex');
	}	

	# Tables - Excessive indexes
        foreach my $dbname (keys $db{database}) {
		$sql = ("select  table_schema, table_name, count(*) from 
			( SELECT  table_schema,table_name, index_name FROM information_schema.statistics  
			WHERE table_schema = '$dbname' GROUP BY  table_name, index_name) 
			tab_ind_cols group by table_name having count(*) > 7;");
		query_db($sql, 'excessindex');
	}

}

sub set_format {
	$f{disk} = "%5s %5s %5s %5s %-60s\n";
	$f{db} = "%-30s %20s\n";
	$f{table} = "%-7s %7s %10s %10s %10s %10s %10s\n";
	$f{frag} = "%-20s %-48s %-10s %-10s\n";
	$f{keys} = "%-20s %-20s\n";
	$f{noidx} = "%-20s %-48s %-20s %-10s %-10s\n";
	$f{xsidx} = "%-20s %-48s %-20s\n";
	
	unless($opt{format}) {
		foreach my $key (keys %f) {
			$f{$key} =~ s/-?\d+?(\w)\s/$1,/g;
			$f{$key} =~ s/,$/\n/g;
		}
	}
}

sub print_report {
# System Summary
	print "\n\n_________________________ [CogecoPeer1 DBA Report] _________________________\n\n";
	print "Version: $version\n";
	print "Date: $sys{Date}\n";
	print "Hostname: $sys{Hostname}\n";
        print "IP addresses: ";
        foreach(@{$sys{IPAddresses}}) { print "$_  "; }
        print "\n";
	print "System: $sys{OSVersion}\n";
	print "MySQL: $vars{version}\n";
	print "System uptime: $sys{SystemUptime}\n";
	print "MySQL uptime: $sys{MySQLUptime}\n";

# Summary action points
	print "\n[Summary]\n";
	if (defined $cpu{LoadAverageOverCount}) { print "CPU: The 15min load average was above 75% total utilization on $cpu{LoadAverageOverCount} times in the last $cpu{TotalSarLogs} days.\n"; }
	if ($mem{MySQLUsedPerc} >= 95) { print "Memory: MySQL is configured to use up to $mem{MySQLUsedPerc}% of the system memory. This can cause the system to swap to disk & may degrade performance\n"; }
	if ($mem{SwapFreePerc} <= 90) { print  "Memory: The system is using $mem{SwapUsed} of swap. This can dramatically reduce MySQL performance.\n"; }
	foreach(@{$sys{DiskAlerts}}) { print "Disk: $_\n"; }
	if ($sys{CP1Updates} eq 1) { print "System: Automatic updating is disabled. You can enable this by installing the 'yum-p1mh-autoupdates' package.\n"; }
	if ($sys{KernelInUse} ne $sys{LastKernelVersion}) { print "System: A kernel update requires a reboot.\n"; }
	unless ($sys{BackupCronFound}) { print "Backups: No scheduled backup was detected.\n"; }
	if ($db{tables}{MyISAM}) { print "MySQL: There are $db{tables}{MyISAM}[0] MyISAM table(s).\n"; }
	unless ($vars{'tmpdir'} =~ /shm/) { print "MySQL: For optimal performance, set the MySQL temporary directory to /dev/shm.\n"; }      
	if ($db{frag}) { print "MySQL: There are " . scalar (keys $db{frag}) . " fragmented tables.\n"; }
	if ($db{ukeys}) { print "MySQL: There are " . scalar (keys $db{ukeys}) . " tables without a primary or unique key.\n"; }
	if ($db{noindex}) { print "MySQL: There are " . scalar (keys $db{noindex}) . " tables without an index.\n"; }
	if ($db{excessindex}) { print "MySQL: There are " . scalar (keys $db{excessindex}) . " tables with excessive indexes.\n"; }

# CPU usage
        print "\n[CPU Info]\n";
        print "Model: $cpu{ModelName} (x$cpu{Sockets})\nCores: $cpu{TotalCores}\nThreads: $cpu{TotalThreads}\n";
        print "$cpu{TotalSarLogs} day average load: $cpu{LoadAve}\n";
        if (defined $cpu{LoadAverageOverCount}) {
                print "\nThe 15min load average was above 75% total utilization on $cpu{LoadAverageOverCount}  times in the last $cpu{TotalSarLogs} days.\n";
        } else {
                print "\nNo issues found. The CPU total utilization has stayed below 75% for the last $cpu{TotalSarLogs} days.\n";
        }
        if ($cpu{Sockets} >= 2 && $vars{innodb_numa_interleave} eq "OFF") {
                print "Non Uniform Memory Access (NUMA) is enabled in the CPUs, but not in MySQL.\n";
                print "Adding innodb_numa_interleave=1 to the MySQL configuration may improve performance.\n";
        }

# Memory usage
	print "\n[Memory Usage]\n";
	print "Total memory: $mem{MemTotal} \nFree memory: $mem{MemFree} ($mem{MemFreePerc}%)\nCached: $mem{Cached} \n";
	print "Total swap: $mem{SwapTotal} \nFree swap: $mem{SwapFree} ($mem{SwapFreePerc}%)\n";
	print "MySQL max configured memory: $mem{MySQLMaxConfigured} ($mem{MySQLUsedPerc}%)\n";
	print "MySQL max used memory: $mem{MySQLMaxUsed}\n";
	print "Base memory: $mem{MySQLBase} | Per Connection: $mem{MySQLPerConnection} | Max Connections: $vars{max_connections} | Max used Connections: $stats{Max_used_connections}\n\n";
	if ($mem{MySQLUsedPerc} >= 95) {
		print "MySQL is configured to use up to $mem{MySQLUsedPerc}% of the system memory.\nThis can cause the system to swap to disk & may degrade performance\n";
		$mem{MySQLWarn} = 1;
	}
        if ($mem{SwapFreePerc} <= 90) {
                print  "The system is using $mem{SwapUsed} of swap. This can dramatically reduce MySQL performance.\n";
		$mem{MySQLWarn} = 1;
        }
        if ( `sysctl -n vm.swappiness` > 10 ) {
                print "Swappiness is > 10. This should be set lower than 10 to prevent unnecessary swapping.\n";
		$mem{MySQLWarn} = 1;
        }
	if ($stats{Max_used_connections} >= $vars{max_connections}) {
		print "MySQL has reached the maximum number of concurrent connections.\n";
		if ($mem{MySQLPossibleMaxConnections} >= $vars{max_connections}) {
			print "Based on the current settings the max_connections could be increased up to $mem{MySQLPossibleMaxConnections}.\n";
		} else {
			print "There are insufficient resources to increase the max_connections.\n";
		}
		$mem{MySQLWarn} = 1;
	}
	unless (defined $mem{MySQLWarn}) { print "No issues found.\n"; }

# Disk usage
        my @disk_alerts;
        print "\n[Disk Usage]\n";
	printf $f{disk}, "Size","Used","Avail","Use%","Mounted on";
        foreach my $filesystem (keys %fsinfo) {
                printf $f{disk}, $fsinfo{$filesystem}{TotalSize},$fsinfo{$filesystem}{Used},$fsinfo{$filesystem}{Available},$fsinfo{$filesystem}{PercentUsed},$filesystem;
        }
        print "\n";
        foreach(@{$sys{DiskAlerts}}) { print "$_"; }
        unless (@{$sys{DiskAlerts}}) { print "No issues found.\n"; }

# System Updates
	print "\n[System Updates]\n";
	print "Last update time: $sys{LastUpdateTime}\n";
	print "Last reboot time: $sys{TimeOfReboot}\n";
	print "Kernel in use: $sys{KernelInUse}\n";
	print "Kernel update: $sys{LastKernelVersion}\n";
	if ($sys{KernelInUse} ne $sys{LastKernelVersion}) {
		print "\nA kernel update requires a reboot.\n";
	} else {
		print "\nRunning latest kernel update.\n";
	}
	if ($sys{CP1Updates} eq 0) {
		print "Automatic updating is enabled.\n";
	} else {
		print "Automatic updating is disabled.\nYou can enable this by installing the 'yum-p1mh-autoupdates' package.\n";
	}

# Backups
	print "\n[Backups]\n";
	if ($sys{BackupCronFound}) { 
		foreach(@{$sys{BackupCron}}) { print "Crontab [Y] - $_"; }
	} else {
		print "Crontab [N] - No scheduled backup was detected.\n";
		$sys{BackupWarn} = "1";
	}
	if ($sys{BackupDirFound}) {
		foreach(@{$sys{BackupDir}}) { print "Backup directory [Y] - $_\n"; } 
	} else {
		print "Backup directory [N] - No backup directory was found.\n\n";
	}
	if ($sys{TivoliInstalled}) {
		print "Tivoli installed? [Y] - /opt/tivoli\n"
	} else {
		print "Tivoli installed? [N] - Tivoli backup was not detected on this server.\n\n";
	}
	if ($sys{BackupWarn}) {
		print "We recommend all customers backup their databases on a daily basis.\nIf you would like assistance setting up a backup script, please let us know.\n";
	} else {
		print "No issues found.\n";
	}

# Databases
	print "\n[Databases]\n";
	printf $f{db}, "Database Name", "Database size (MB)";
	foreach my $key ( keys $db{database}) {
		printf $f{db}, $key, @{$db{database}{$key}};
	}

# Tables
	print "\n[Tables]\n";
	printf $f{table}, "Engine", "  Tables", "Rows", "Data", "Index", "Size", "idxfrac";
	foreach my $key ( keys $db{tables}) {
		printf $f{table}, $key, @{$db{tables}{$key}};
	}

# Tables - unique keys / indexing
	if ($db{frag}) {
		print "\n[Fragmented Tables]\n";
		printf $f{frag}, "Database", "Table", "Free (MB)", "Engine";
		foreach my $key (keys $db{frag}) {
	                printf $f{frag}, $key, @{$db{frag}{$key}};
		}
	}
	if ($db{ukeys}) {
		print "\n[Missing Primary / Unique Keys]\n";
		printf $f{keys}, "Database", "Table";
		foreach my $key (keys $db{ukeys}) {
			printf $f{keys}, $key, @{$db{ukeys}{$key}};
		}
	}

	if ($db{noindex}) {
		print "\n[No Indexes]\n";
		printf $f{noidx}, "Database", "Table", "Collation", "Engine", "Rows";	
		foreach my $key (keys $db{noindex}) {
			printf $f{noidx}, $key, @{$db{noindex}{$key}};
		}
	}
	if ($db{excessindex}) {
		print "\n[Excess Indexes]\n";
		printf $f{xsidx}, "Database", "Table", "Indexes";
		foreach my $key (keys $db{excessindex}) {
			printf $f{xsidx}, $key, @{$db{excessindex}{$key}};
		}
	}

# Table Cache
	print "\n[Table Cache\n";
	print "Open: $stats{'Open_tables'} of $vars{'table_cache'} Cached: " . percent($stats{'Open_tables'}, $vars{'table_cache'}) . "% \n";
	print "Opened: " . short($stats{'Opened_tables'}) . " (" . short($stats{'Opened_tables'} / $stats{'Uptime'}, 0, 1) . "/s)\n";
	if ($stats{Open_tables} >= (($sys{ulimit} / 100) * 90)) {
	
	}
		
	if ($stats{Open_tables} >= $vars{table_cache}) {
		#table cache is full. 
		#MyISAM requires 2 file descriptors per open table.
		#MySQL's hard ulimit is $sys{ulimit}
		#Count of MyISAM tables : $db{Tables}{MyISAM}[0]
		#Count of open files: $sys{MySQLOpenFiles}
	}

#        my $pc_on_disk = perc($stats{'Created_tmp_disk_tables'}, $stats{'Created_tmp_tables'});
#        print "\n[Temporary Tables]\n";
#        print "Total: $stats{'Created_tmp_tables'}\n";
#        print "Disk: $stats{'Created_tmp_disk_tables'} ($pc_on_disk%)\n";
#        print "Tmpdir: $vars{tmpdir}\n";
#        unless ($vars{'tmpdir'} =~ /shm/) {push @summary, "Consider setting tmpdir to /dev/shm if available.\n";}



}

sub debug {
	
	#print Dumper \%fsinfo;
	#print Dumper \%cpu;
	#print Dumper \%mem;
	print Dumper \%sys;
	#print Dumper \%db;
}


###TODO:  quit if not root
get_mycnf();
connect_db();
get_stats();
get_vars();
get_cpu_usage();
get_memory_usage();
get_disk_usage();
get_system_info();
get_backup_info();
get_database_info();
set_format();
#print_report();
debug();
