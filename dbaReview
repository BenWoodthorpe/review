#!/usr/bin/env perl 
#

use strict;
use warnings;
use DBI;
use Getopt::Long;

my $version = "2.0.8";


our (%mycnf, %mem, %opt, $dbh, %vars, %stats, %fsinfo, %cpu, %sys, %db, %f, %summary); 

GetOptions(
        \%opt, 'username=s', 'password=s', 'help', 'host=s', 'socket=s', 'update', 'format', 'review', 'debug=s', 'query=s', 'showall', 
);

sub usage {
        print "\n"
        . "$0 v.${version}\n"
        . "Usage:\n\n"
        . "-user 	<username>      Specify user\n"
        . "-pass 	<password>      Specify password\n"
        . "-host 	<host>          Specify IP/host\n"
        . "-socket <socket>      	Specify socket\n"
        . "-help 			Usage (this message)\n"
        . "-update            	Update to latest version\n"
	. "-query	<search term>	Search MySQL variables / status for <search term>\n"
	. " 			Case insensitive and accepts perl style regex e.g. -q 'innodb.+(size|type)'\n"
	. "			Also supports searching values of variables e.g. -q 3306\n"            
	. "-review			Print full diagnostic data\n"
	. "-showall		Print all tables with issues rather than top 10 (May take a while!)\n"
	. "-format			Use with -review for formatted tables (default is csv)\n"
	. "-d tables		Print a CVS listing of all tables with missing indexes etc..\n"
        . "\n"
        . "* If no user or password is supplied, this script will attempt to login using\n"
        . "either Plesk credentials (if installed) or as a fallback it will check ~/.my.cnf.\n\n";
        exit;
}

sub update {
        print "Checking for updates...\n";
        my $url = "https://netcrypt.eu/dl/$0";
        my $httpcli = `which curl`;
        chomp ($httpcli);
        my $update;
        if (defined ($httpcli) and -e "$httpcli") {
                $update = `$httpcli --connect-timeout 5 --silent '$url' 2>/dev/null | grep 'my \$version'| cut -d\\\" -f2`;
        } else {
                print "Unable to find curl.\n";
                exit;
        }
        chomp ($update);
        unless ($update =~ /^\d\.\d.*/ ) { print "Unable to determine version number. Please update manually - wget $url\n"; exit; }
        if ($update ne $version) {
                print "A newer version ($update) is available. Downloading...\n";
                my $backup = `cp $0 $0.bak`;
                print "$0 saved as $0.bak\n";
                my $download = `$httpcli --connect-timeout 5 --silent '$url' -o $0`;
                chmod 0755, $0;
                print "Updated to the latest version ($update). Please re-run $0\n";
        } else {
                print "You have the latest version of $0 ($version)\n";
        }
        exit;
}


sub get_mycnf {
        # No user / pass was supplied
        if ( -r "/etc/psa/.psa.shadow" ) { # It's a Plesk box
                $mycnf{user} = "admin";
                open DOTPSA, "/etc/psa/.psa.shadow" or warn "Can't open the /etc/psa/.psa.shadow file. $!\n";
                $mycnf{pass} = <DOTPSA>;
                close DOTPSA;
                return;
        }
        open MYCNF, "$ENV{HOME}/.my.cnf" or warn "Can't open the .my.cnf file. $!\n"; # Last resort - check for ~/.my.cnf
        while(<MYCNF>) {
                if(/^(.+?)\s*=\s*"?(.+?)"?\s*$/) {
                        $mycnf{$1} = $2;
                }
        }
        $mycnf{pass} ||= $mycnf{password} if exists $mycnf{password};
        close MYCNF;
}


sub connect_db {
        my $dsn;
        if ($opt{socket}) {
                $dsn = "DBI:mysql:mysql_socket=$opt{socket}";
        } else {
                $dsn = "DBI:mysql:host=$mycnf{host}";
        }
        $dbh = DBI->connect($dsn, $mycnf{user}, $mycnf{pass}) or usage();
}

sub get_stats {
        my $query = $dbh->prepare("SHOW GLOBAL STATUS;");
        $query->execute();
        my @row;
        while(@row = $query->fetchrow_array()) { $stats{$row[0]} = $row[1];}
	$db{select}  = $stats{Com_select};
	$db{insert}  = $stats{Com_insert}  + $stats{Com_insert_select};
	$db{replace} = $stats{Com_replace} + $stats{Com_replace_select};
	$db{update}  = $stats{Com_update}  + (exists $stats{Com_update_multi} ? $stats{Com_update_multi} : 0);
	$db{delete}  = $stats{Com_delete}  + (exists $stats{Com_delete_multi} ? $stats{Com_delete_multi} : 0);
        $db{key_read_ratio} = sprintf "%.0f",($stats{'Key_read_requests'} ? 100 - ($stats{'Key_reads'} / $stats{'Key_read_requests'}) * 100 : 0);
        $db{key_write_ratio} = sprintf "%.0f",($stats{'Key_write_requests'} ? 100 - ($stats{'Key_writes'} / $stats{'Key_write_requests'}) * 100 : 0);
        $db{key_cache_block_size} = (defined $vars{'key_cache_block_size'} ? $vars{'key_cache_block_size'} : 1024);
	$db{innodb_buffer_used} = ($stats{'Innodb_buffer_pool_pages_total'} - $stats{'Innodb_buffer_pool_pages_free'}) * $stats{'Innodb_page_size'};
	$db{innodb_buffer_total} = $stats{'Innodb_buffer_pool_pages_total'} * $stats{'Innodb_page_size'};
	$db{innodb_buffer_hits} = sprintf "%.0f", ($stats{'Innodb_buffer_pool_read_requests'} ? 100 - ($stats{'Innodb_buffer_pool_reads'} / $stats{'Innodb_buffer_pool_read_requests'}) * 100 : 0);
	$stats{Innodb_deadlocks} = exists $stats{Innodb_deadlocks} ? $stats{Innodb_deadlocks} : 0;
        $query = $dbh->prepare("SHOW SLAVE STATUS;");
        $query->execute();
        while (my $myhr = $query->fetchrow_hashref()) {
                for (keys %$myhr) {
                        $db{replication}{$_} = $$myhr{$_};
                }
        }
}

sub get_vars {
        my $query = $dbh->prepare("SHOW VARIABLES;");
        $query->execute();
        my @row;
        while(@row = $query->fetchrow_array()) { $vars{$row[0]} = $row[1]; }
        $vars{'table_cache'} = $vars{'table_open_cache'} if exists $vars{'table_open_cache'};
        unless (defined $vars{'skip_name_resolve'}) { $vars{'skip_name_resolve'} = "NULL";}
        unless (defined $vars{'slow_query_log'}) { $vars{'slow_query_log'} = "NULL";}
        unless (defined $vars{'slow_query_log_file'}) { $vars{'slow_query_log_file'} = "NULL";}
        $vars{'innodb_additional_mem_pool_size'} = exists $vars{'innodb_additional_mem_pool_size'} ? $vars{'innodb_additional_mem_pool_size'} : 0;
        $vars{'innodb_buffer_pool_size'} = exists $vars{'innodb_buffer_pool_size'} ? $vars{'innodb_buffer_pool_size'} : 0;
        $vars{'innodb_log_buffer_size'} = exists $vars{'innodb_log_buffer_size'} ? $vars{'innodb_log_buffer_size'} : 0;
        $vars{'innodb_buffer_pool_instances'} = exists $vars{'innodb_buffer_pool_instances'} ? $vars{'innodb_buffer_pool_instances'} : 1;
}

sub short {
	# Shortens numbers.
        # number, is it kilobytes?, decimal places
        my ($number, $kb, $d) = @_;
        my $n = 0;
        my $short;

        $d ||= 0;

        if($kb) { while ($number > 1023) { $number /= 1024; $n++; }; }
        else { while ($number > 999) { $number /= 1000; $n++; }; }

        $short = sprintf "%.${d}f%s", $number, ('','k','M','G','T')[$n];
        if($short =~ /^(.+)\.(00)$/) { return $1; } # 12.00 -> 12 but not 12.00k -> 12k

        return $short;
}

sub sec2time {
	my $uptime  = shift;
	my $seconds = $uptime % 60;
	my $minutes = int( ( $uptime % 3600 ) / 60 );
	my $hours   = int( ( $uptime % 86400 ) / (3600) );
	my $days    = int( $uptime / (86400) );
	my $uptimestring;
	if ( $days > 0 ) {
		$uptimestring = "${days}d ${hours}h ${minutes}m ${seconds}s";
	} elsif ( $hours > 0 ) {
		$uptimestring = "${hours}h ${minutes}m ${seconds}s";
	} elsif ( $minutes > 0 ) {
		$uptimestring = "${minutes}m ${seconds}s";
	} else {
		$uptimestring = "${seconds}s";
	}
	return $uptimestring;
}

sub percent {
	# Find the percentage
        my($is, $of) = @_;
        return sprintf "%.0f", ($is * 100) / ($of ||= 1);
}

sub ordsuf ($) {
	# package Lingua::EN::Numbers::Ordinate
	# Provides the correct suffix to a number e.g. 1st 2nd 3rd 4th etc...
	return 'th' if not(defined($_[0])) or not( 0 + $_[0] );
	my $n = abs($_[0]);  
	return 'th' unless $n == int($n);
	$n %= 100;
	return 'th' if $n == 11 or $n == 12 or $n == 13;
	$n %= 10;
	return 'st' if $n == 1; 
	return 'nd' if $n == 2;
	return 'rd' if $n == 3;
	return 'th';
}

sub get_memory_usage {
        open MEMINFO, "/proc/meminfo" or return;
        while( my $line = <MEMINFO>) {
                chomp($line);
                my ($memstat, $memvalue) = split (/:/, $line);
		$memvalue =~ s/^\s+(\d+)\s?\w*/$1/g;
                $mem{$memstat} = $memvalue;
        }
        close MEMINFO;
# MySQL
        $mem{MySQLBase} = ($vars{key_buffer_size} + $vars{query_cache_size} + $vars{innodb_buffer_pool_size} + $vars{innodb_additional_mem_pool_size} + $vars{innodb_log_buffer_size});
        $mem{MySQLPerConnection} = ($vars{read_buffer_size} + $vars{read_rnd_buffer_size} + $vars{sort_buffer_size} + $vars{join_buffer_size} + $vars{binlog_cache_size} + $vars{thread_stack});
	$mem{MySQLPossibleMaxConnections} = int ((((($mem{MemTotal} * 1024) / 100) * 90) - $mem{MySQLBase}) / $mem{MySQLPerConnection});
        $mem{MySQLMaxConnectionConfigured} = ($mem{MySQLPerConnection} * $vars{max_connections});
        $mem{MySQLMaxConnectionUsed} = ($mem{MySQLPerConnection} * $stats{Max_used_connections});
        $mem{MySQLMaxConfigured} = short(($mem{MySQLBase} + $mem{MySQLMaxConnectionConfigured}), 1);
	$mem{MySQLMaxConfiguredRaw} = ($mem{MySQLBase} + $mem{MySQLMaxConnectionConfigured});
        $mem{MySQLMaxUsed} = short(($mem{MySQLBase} + $mem{MySQLMaxConnectionUsed}), 1);
	$mem{MySQLUsedPerc} = percent(($mem{MySQLMaxConnectionConfigured} + $mem{MySQLBase}), ($mem{MemTotal} * 1024));
        $mem{RemainingMem} = (($mem{MemTotal} * 1024) - ($mem{MySQLMaxConnectionConfigured} + $mem{MySQLBase}));

	$mem{MySQLBase} = short($mem{MySQLBase});
	$mem{MySQLPerConnection} = short($mem{MySQLPerConnection});
# System
	$mem{MemFreePerc} = percent($mem{MemFree},$mem{MemTotal});
	$mem{MemTotal} = short(($mem{MemTotal} * 1024), 1);
	$mem{MemFree} = short(($mem{MemFree} * 1024), 1);
	$mem{Cached} = exists $mem{Cached} ? short(($mem{Cached} * 1014), 1) : "0";
        $mem{SwapUsed} = exists $mem{SwapTotal} ? short((($mem{SwapTotal} * 1024) - ($mem{SwapFree} *1024)), 1) : "0";
	$mem{SwapFreePerc} = exists $mem{SwapTotal} ? percent($mem{SwapFree},$mem{SwapTotal}) : "0";
	$mem{SwapTotal} = exists $mem{SwapTotal} ? short(($mem{SwapTotal} * 1024), 1) : "0";
	$mem{SwapFree} = exists $mem{SwapTotal} ? short(($mem{SwapFree} * 1024), 1) : "0";
}

sub get_disk_usage {
	my @df_out = `/bin/df -lh`;
	foreach (@df_out) {
		if ($_ =~ /\d\%/) {
			my ($line, $filesystem) = split (/% /, $_);
			chomp ($filesystem);
			my @fields = split(/\s+/, $line);
			$fsinfo{$filesystem}{TotalSize} = $fields[1];
			$fsinfo{$filesystem}{Used} = $fields[2];
			$fsinfo{$filesystem}{Available} = $fields[3];
			$fsinfo{$filesystem}{PercentUsed} = $fields[4];
	                if ($fsinfo{$filesystem}{PercentUsed} >= 85) {
	                        unless ($filesystem =~ /run/) { push @{$summary{Disk}}, "[*] The '$filesystem' filesystem is $fsinfo{$filesystem}{PercentUsed}% used.\n";}
	                }

		}
	}
}

sub get_cpu_usage {
        my @lscpu;
        if ( -e "/usr/bin/lscpu") { @lscpu = `lscpu`; }
		if (@lscpu) {
			foreach my $line (@lscpu) {
				chomp($line);
				$line =~ s/[()]//g;
				my ($name, $number) = split /:/, $line;
				$name =~ s/([\w']+)/\u\L$1/g;
				$name =~ s/\s+//g;
				$number =~ s/^\s+//g;
				$cpu{$name} = $number;
			}
			$cpu{TotalCores} = ($cpu{CoresPerSocket} * $cpu{Sockets});
			$cpu{TotalThreads} = ($cpu{ThreadsPerCore} * $cpu{TotalCores});
			$cpu{Max15MinLoad} = ($cpu{Cpus} * 0.75);
		} else {
			my $m_seen = 0;
			my $c_seen = 0;
			my %c_count;
			open CPUINFO, "/proc/cpuinfo" or return;
			while (my $line = <CPUINFO>) {
				if ($line =~ m/model name/ && $m_seen eq '0') {
					($cpu{ModelName} = $line) =~ s/model name\s+?: (\w+?)/$1/g;
					chomp($cpu{ModelName});
					$m_seen = 1;
				}
				if ($line =~ m/cpu cores/ && $c_seen eq '0') {
					($cpu{TotalCores} = $line) =~ s/cpu cores\s+?: (\d+?)/$1/g;
					chomp($cpu{TotalCores});
					$c_seen = 1;
				}
				if ($line =~ m/processor/) {
					$cpu{TotalThreads}++;
				}
				if ($line =~ m/physical id/) {
					my ($id, $count) = split (/:/, $line);
					$c_count{$count} = $id;
				}
			}
			$cpu{Sockets} = scalar keys %c_count;
			unless ($cpu{TotalCores}) { $cpu{TotalCores} = "Virtual CPU"; }
			$cpu{Max15MinLoad} = ($cpu{TotalThreads} * 0.75);
			$cpu{Cpus} = $cpu{TotalThreads};

	}

########
	unless ( -d "/var/log/sa" ) { return;}
        opendir my $dir, "/var/log/sa" or return;
        my @sar_logs = readdir $dir;
        closedir $dir;
        foreach my $log(@sar_logs) {
                next if ($log =~ /sar/);
                next if ($log =~ /^\.\.?$/);
                $cpu{TotalSarLogs}++;
                my @daily_load_ave = `sar -f /var/log/sa/$log -q | egrep -v 'Linux|runq|Average'`;
                foreach my $ldav(@daily_load_ave) {
                        next if ($ldav =~ /^\s?$/);
                        my @fifteen_load_ave = split(' ', $ldav);
                        chomp(@fifteen_load_ave);
                        next unless (defined $fifteen_load_ave[5]);
			$cpu{LoadTotal} += $fifteen_load_ave[5];
			$cpu{LoadCount}++;
                        if ($fifteen_load_ave[5] >= $cpu{Max15MinLoad}) {
                                $cpu{LoadAverageOverCount}++;
                        }
                }
        }
	$cpu{LoadAve} = sprintf '%.0f%%', 100 * (($cpu{LoadTotal} / $cpu{Cpus}) / $cpu{LoadCount});
}

sub get_system_info {
        unless ( -e "/etc/redhat-release" ) { return; }
	$sys{Hostname} = `hostname`;
	$sys{OSVersion} = `cat /etc/redhat-release`;
	$sys{Date} = `date "+%B %Y"`;
	chomp($sys{Day} = `date "+%e"`);
	$sys{DaySuffix} = ordsuf($sys{Day});
        $sys{Date} = "$sys{Day}$sys{DaySuffix} $sys{Date}";
	@{$sys{IPAddresses}} = (`ip -o addr show up primary scope global` =~ /inet\s(\d+\.\d+\.\d+\.\d+)/g);
	$sys{MySQLUptime} = sec2time($stats{Uptime}); 
	($sys{LastKernelVersion}, $sys{LastUpdateTime}) = split (/ {2,}/, `rpm -q kernel --last | head -n1`);	
	$sys{LastUpdateTime} =~ s/\s+(AM|PM).*//g;
	($sys{UptimeSeconds} = `cat /proc/uptime`) =~ s/(^\d+?)\..*/$1/g;
	$sys{SystemUptime} = sec2time($sys{UptimeSeconds});
	($sys{TimeOfReboot} = time()) -= $sys{UptimeSeconds};
	$sys{TimeOfReboot} = localtime($sys{TimeOfReboot});
        my ($wday, $mon, $mday, $rtime, $year) = split(' ', $sys{TimeOfReboot});
	$mday = sprintf "%02d", $mday;
        $sys{TimeOfReboot} = "$wday $mday $mon $year $rtime";
        $sys{KernelInUse} = `uname -r`;
	$sys{LastKernelVersion} =~ s/kernel-//g;
	$sys{CP1Updates} = `rpm -q yum-p1mh-autoupdates`;
	$sys{CP1Updates} = $? >> 8;
	chomp($sys{MySQLPID} = `pidof mysqld`);
	@{$sys{ulimit}} = split (/\s+/,`grep "open files" /proc/$sys{MySQLPID}/limits`); 
	$sys{ulimit} = @{$sys{ulimit}}[3];
	$sys{MySQLOpenFiles} = `lsof -p $sys{MySQLPID} | wc -l`;
	chomp(%sys);
}

sub get_backup_info {
	@{$sys{RootCron}} = `crontab -l 2>/dev/null`;
        foreach(@{$sys{RootCron}}) {
		next if /^#/;
                if ($_ =~ /db|mysql|database|backup/) {
                        $sys{BackupCronFound} = "1";
                        chomp($_);
	                my @arr = split (/\s+/,$_);
        	        $arr[5]=join(" ",splice(@arr,5));
                	@{$sys{DaysOfWeek}} = ("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday", "Daily");
                	my ($min, $hour, $dom, $month, $dow, $command) = @arr;
                        if ($dow =~ /\d/) { $dow = $sys{DaysOfWeek}[$dow]; } else { $dow = $sys{DaysOfWeek}[8]; }
			if ($hour =~ /\//) { 
				my @entry = split(/\//, $hour); 
				$hour = "Every $entry[1] hours"; 
				push @{$sys{BackupCron}}, sprintf ("%-15s %-10s %-50s\n", $hour,"($dow)",$command);
				next;
			}
                        if ($min =~ /,|-/ || $hour =~ /,|-/) {
	                        push @{$sys{BackupCron}}, sprintf ("Hours:%-5s Mins:%-5s %-10s %-50s\n", $hour,$min,"($dow)",$command);
                                next;
                        }

			push @{$sys{BackupCron}}, sprintf ("%02d:%02d %-10s %-50s\n",$hour,$min,"($dow)",$command);
                }
        }
	@{$sys{KnownBackupDirs}} = ('/backup', '/backups', '/home/backups', '/var/lib/mysql/backups', '/var/backup/db', '/home/dbdumps');
	foreach(@{$sys{KnownBackupDirs}}) {
		if (-d $_) {
			$sys{BackupDirFound} = "1";
			chomp($_);
			push @{$sys{BackupDir}}, $_;
		}
	}
	if (-d "/opt/tivoli") { $sys{TivoliInstalled} = "1"; }
}

####### MySQL

sub query_db {
	my ($sql, $name, $qt) = @_;
	my $query = $dbh->prepare("$sql");
	$query->execute;
	while (my @out = $query->fetchrow_array()) {
                next unless ($out[0]);
		foreach (@out) {$_ = 'null' unless defined};
		if (defined $qt) {
			$db{$name} = $out[0];
		} else {
			@{$db{$name}{$out[0]}} = splice(@out,1); 
		}
	}
}

sub run_queries {
	# Databases
	my $sql = ("select table_schema,  truncate(sum(data_length + index_length)/1024/1024,2) AS size, COUNT(if (engine = 'myisam',1,NULL)) 'MyISAM', COUNT(if (engine = 'innodb',1,NULL)) 'InnoDB', COUNT(if (engine IS NULL,1,NULL)) 'Views', count(*) as Total   FROM information_schema.tables WHERE table_schema not in ('mysql', 'performance_schema', 'information_schema', 'sys') group by table_schema ORDER BY size DESC;");
	query_db($sql, 'database');

	# Tables - Engines
	$sql = ("SELECT engine,
                 count(*) as TABLES,
                 concat(round(sum(table_rows)/1000000,2),'M') `rows`,
                 concat(round(sum(data_length)/(1024*1024*1024),2),'G') DATA,
                 concat(round(sum(index_length)/(1024*1024*1024),2),'G') idx,
                 concat(round(sum(data_length+index_length) / (1024*1024*1024),2),'G') total_size,
                 round(sum(index_length)/sum(data_length),2) idxfrac
                 FROM information_schema.TABLES
                 WHERE table_schema not in
                 ('mysql', 'performance_schema', 'information_schema', 'sys')
                 GROUP BY engine
                 ORDER BY sum(data_length+index_length) DESC LIMIT 10;");
	query_db($sql, 'tables');
	
	foreach my $engine (keys %{$db{tables}}) {
		$db{TableCount} += $db{tables}{$engine}[0];
	}

	# Workout the optimal thread_cache_size (8 + (max_connections / 100) but no more than 100)
        $db{Threads} = short(8 + ( $vars{'max_connections'} / 100)); 
	if ($db{Threads}  >= 100 ) { $db{Threads} = '100'; }

	# Workout the minimum recommended innodb_buffer_pool_size 
	$sql = ("SELECT CEILING(Total_InnoDB_Bytes) RIBPS FROM
 		(SELECT SUM(data_length+index_length) Total_InnoDB_Bytes
 		FROM information_schema.tables WHERE engine='InnoDB') A;");
	query_db($sql, 'BufferSize', 1);

	# Anon users
        $sql = ("SELECT CONCAT(user, '\@', host), Super_priv FROM mysql.user WHERE TRIM(USER) = '' OR USER IS NULL");
        query_db($sql, 'useranon');

	# Users with no password
        if ($vars{'version'} =~ /5.7/) {
                $sql = ("SELECT CONCAT(user, '\@', host), Super_priv  FROM mysql.user WHERE authentication_string = '' OR authentication_string IS NULL");
        } else {
                $sql = ("SELECT CONCAT(user, '\@', host), Super_priv  FROM mysql.user WHERE password = '' OR password IS NULL");
        }
        query_db($sql, 'usernopasswd');

	# Users with no host restrictions
        $sql = ("SELECT CONCAT(user, '\@', host), Super_priv FROM mysql.user WHERE HOST='%'");
        query_db($sql, 'usernohost');


	#
	# Return here if there are > 10000 tables     
	# as this can cause problems (locking / slow) 
	# (Unless -showall is selected)               
        #

	if ($db{TableCount} >= 10000 and not $opt{showall}) { return; }

	# Tables - Fragmentation
	$sql =	("SELECT table_name, table_schema, 
                  round((data_free /1024/1024),0) AS FREE, 
                  engine FROM information_schema.tables 
                  WHERE table_schema  NOT IN ('information_schema', 'mysql') 
                  AND (data_free/1024/1024) > 50;"); 
	query_db($sql, 'frag');

	# Tables - No primary / unique keys
	$sql = ("SELECT t.table_name,t.table_schema 
		 FROM information_schema.tables t 
		 INNER JOIN information_schema.columns c on t.table_schema=c.table_schema and t.table_name=c.table_name 
		 and t.table_schema not in ('performance_schema','information_schema','mysql','sys') 
		 GROUP BY t.table_schema,t.table_name,t.engine HAVING sum(if(column_key in ('PRI','UNI'), 1,0)) =0 and t.engine IS NOT NULL;");
	query_db($sql, 'ukeys');
	
	# Tables - No index
	foreach my $dbname (keys %{$db{database}}) {
		$sql = ("SELECT table_name,table_schema,table_collation,engine,table_rows FROM INFORMATION_SCHEMA.tables 
         		 WHERE table_schema = '$dbname' AND table_rows IS NOT NULL 
                	 AND table_name NOT IN ( SELECT table_name FROM ( SELECT table_name, index_name FROM information_schema.statistics WHERE table_schema = '$dbname' 
                	 GROUP BY table_name, index_name) tab_ind_cols group by table_name );");
		query_db($sql, 'noindex');
	}	

	# Tables - Excessive indexes
        foreach my $dbname (keys %{$db{database}}) {
		$sql = ("select  table_name, table_schema, count(*) from 
			( SELECT  table_schema,table_name, index_name FROM information_schema.statistics  
			WHERE table_schema = '$dbname' GROUP BY  table_name, index_name) 
			tab_ind_cols group by table_name having count(*) > 7;");
		query_db($sql, 'excessindex');
	}

}

sub gfl {
	# Get the max field length to allow prettier formating
	my ($field, $type) = @_;
	$type ||= 0;
	my $largest = "";
	my $value;
	return(10) unless (defined $db{$field});
	foreach my $key (keys %{$db{$field}}) {
		$type == 1 ? ($value = $key) : ($value = @{$db{$field}{$key}}[0]);
		if ( length($value) >= length($largest) ) {
			$largest = $value;
		}
	}
	return((length($largest) + 2) < 10 ? "10" : (length($largest) + 2));
}

sub set_format {
	# Set the 'printf' formatting string or unset for csv output
	$f{disk} = "%5s %5s %5s %5s %-60s\n";
	$f{db} = "%-30s %20s %6s %6s %6s %6s\n";
	$f{table} = "%-7s %7s %10s %10s %10s %10s %10s\n";
        $f{frag} = "%-" . gfl('frag') . "s %-" . gfl('frag',1) . "s %-10s %-10s\n";
        $f{keys} = "%-" . gfl('ukeys') . "s %-" . gfl('ukeys',1) . "s\n";
        $f{noidx} = "%-" . gfl('noindex') . "s %-" . gfl('noindex',1) . "s %-20s %-10s %-10s\n";
        $f{xsidx} = "%-" . gfl('excessindex') . "s %-" . gfl('excessindex',1) . "s %-20s\n";
	unless($opt{format}) {
		foreach my $key (keys %f) {
			$f{$key} =~ s/-?\d+?(\w)\s/$1,/g;
			$f{$key} =~ s/,$/\n/g;
		}
	}
}

sub search {
	# Enable searching through the MySQL variables and status
	# Case insensitive and accepts perl style regex e.g. -q 'innodb.+(size|type)'
	my @hashrefs = (\%vars, \%stats);
        my $c;
        my $lg; 
        foreach my $ref(@hashrefs) {
                my @results = grep { /$opt{query}/i } keys %{ $ref };
                my %hash_inverted;
                for (keys %{ $ref }) {
                        my $value = $$ref{$_};
                        push @{ $hash_inverted{$value} }, $_;
                }
                my @vresults = grep { /$opt{query}/i }  keys %hash_inverted;
                if (@results or @vresults) { print "\n_________________________" . (defined $c ? "_ [Global Status] _" : " [Global Variables] ") .  "_________________________\n\n"; }
                unless (defined $lg) { $lg = "50"; }
                foreach(@results) { if (length($_) >= $lg) { $lg = (length($_) + 2); } }
                foreach(@results) { printf "%-${lg}s %-20s\n", $_, $$ref{$_}; }
		foreach(@vresults) { 
                        foreach my $value (@{$hash_inverted{$_}}) {
                                printf "%-${lg}s %-20s\n", $value, $_ unless grep { $_ eq $value } @results; 
                        }
                }
                $c++;
        }
	exit;
}

sub debug {
	# Quick and easy way to debug various hashes
        use Data::Dumper;
        if ($opt{debug} =~ /fsinfo/) { print Dumper \%fsinfo;}
        if ($opt{debug} =~ /cpu/) { print Dumper \%cpu;}
        if ($opt{debug} =~ /mem/) { print Dumper \%mem;}
        if ($opt{debug} =~ /sys/) { print Dumper \%sys;}
        if ($opt{debug} =~ /db/) { print Dumper \%db;}
        if ($opt{debug} =~ /stats/) { print Dumper \%stats;}
        if ($opt{debug} =~ /vars/) { print Dumper \%vars;}
	if ($opt{debug} =~ /tables/) {
		if ($db{frag}) {
                	print "\n[Fragmented Tables]\n";
                	printf $f{frag}, "Database", "Table", "Free (MB)", "Engine";
                	foreach my $key (sort { $db{frag}{$b}[1] <=> $db{frag}{$a}[1] } keys %{$db{frag}}) {
                	        my $dbname = shift @{$db{frag}{$key}};
                        	printf $f{frag}, $dbname, $key, @{$db{frag}{$key}};
                	}
		}
        	if ($db{ukeys}) {
                	print "\n[Missing Primary / Unique Keys]\n";
                	printf $f{keys}, "Database", "Table";
                	foreach my $key (keys %{$db{ukeys}}) {
                	        my $dbname = shift @{$db{ukeys}{$key}};
                	        printf $f{keys}, $dbname, $key, @{$db{ukeys}{$key}};
                	}
		}
		if ($db{noindex}) {
                	print "\n[No Indexes]\n";
                	printf $f{noidx}, "Database", "Table", "Collation", "Engine", "Rows";
                	foreach my $key (keys %{$db{noindex}}) {
                	        my $dbname = shift @{$db{noindex}{$key}};
                	        printf $f{noidx}, $dbname, $key, @{$db{noindex}{$key}};
                	}
        	}
        	if ($db{excessindex}) {
                	print "\n[Excess Indexes]\n";
                	printf $f{xsidx}, "Database", "Table", "Indexes";
                	foreach my $key (keys %{$db{excessindex}}) {
                	        my $dbname = shift @{$db{excessindex}{$key}};
                	        printf $f{xsidx}, $dbname, $key, @{$db{excessindex}{$key}};
                	}
		}
	}
	exit;
}


sub prep_summary {
#cpu
        if (defined $cpu{LoadAverageOverCount}) {
                push @{$summary{CPU}}, "[*] The 15min load average was above 75% total utilization on $cpu{LoadAverageOverCount} times in the last $cpu{TotalSarLogs} days.\n";
        }
        if ($cpu{Sockets} >= 2 && (exists $vars{innodb_numa_interleave} eq "OFF")) {
                push @{$summary{CPU}},  "[*] Non Uniform Memory Access (NUMA) is enabled in the CPUs, but not in MySQL.\n"
		."    Adding innodb_numa_interleave=1 to the MySQL configuration may improve performance.\n";
        }
#mem
        if ($mem{MySQLUsedPerc} >= 95) {
                push @{$summary{Memory}}, "[*] MySQL is configured to use up to $mem{MySQLUsedPerc}% of the system memory.\n"
		."    This can cause the system to swap to disk & may degrade performance.\n";
        }
        if ($mem{SwapFreePerc} <= 90) {
                push @{$summary{Memory}},  "[*] The system is using $mem{SwapUsed} of swap. This can dramatically reduce MySQL performance.\n";
        }
        if ( `sysctl -n vm.swappiness` > 10 ) {
                push @{$summary{Memory}},   "[*] The 'swappiness' is > 10. This should be set lower than 10 to prevent unnecessary swapping.\n";
        }
#sys
        if ($sys{CP1Updates} eq 1) { push @{$summary{System}},  "[*] Automatic updating is disabled. You can enable this by installing the 'yum-p1mh-autoupdates' package.\n"; }
        if ($sys{KernelInUse} ne $sys{LastKernelVersion}) { push @{$summary{System}}, "[*] A kernel update requires a reboot.\n"; }
        unless ($sys{BackupCronFound}) { 
		push @{$summary{System}}, "[*] No scheduled database backup was detected.\n"
		."    We recommend all customers backup their databases on a daily basis.\n"
		."    If you would like assistance setting up a backup script, please let us know.\n"; 
	}
	unless ($sys{ulimit} =~ /unlimited/i) {
        	if ($vars{open_files_limit} > $sys{ulimit}) { 
			push @{$summary{System}},  "[*] MySQL's open_files_limit is set higher than the system allows.\n"
			. "    MySQL: $vars{open_file_limit} System: $sys{ulimit}.\n"; 
		}
	}
#mysql
        if ($stats{Max_used_connections} >= $vars{max_connections}) {
                push @{$summary{Database}},  "[*] MySQL has reached the maximum number of concurrent connections ($vars{max_connections}).\n";
                if ($mem{MySQLPossibleMaxConnections} >= $vars{max_connections}) {
                        push @{$summary{Database}}, "    Based on the current settings the max_connections could be increased up to $mem{MySQLPossibleMaxConnections}.\n";
                } else {
                        push @{$summary{Database}}, "    There are insufficient resources to increase the max_connections.\n";
                }
        }
        if ($db{tables}{MyISAM}) { 
		push @{$summary{Database}}, "[*] There are $db{tables}{MyISAM}[0] MyISAM table(s).\n"
		. "    MyISAM is an older storage engine that uses full table locking rather than row locking.\n"
		. "    A mixed join of InnoDB and MyISAM tables will escalate to table locking.\n"
		. "    In addition, recovering tables using MyISAM engine will be more difficult in case of a crash.\n"
		. "    As of MySQL version 5.6, InnoDB supports full-text searching.\n"
		. "    We recommend all customers move to using the InnoDB storage engine.\n"; 
	}
        unless ($vars{'tmpdir'} =~ /shm/) { push @{$summary{Database}}, "[*] For optimal performance, set the MySQL temporary directory to /dev/shm.\n"; }
        if ($db{frag}) { push @{$summary{Database}}, "[*] There are " . scalar (keys %{$db{frag}}) . " fragmented tables.\n"; }
        if ($db{ukeys}) { push @{$summary{Database}}, "[*] There are " . scalar (keys %{$db{ukeys}}) . " tables without a primary or unique key.\n"; }
        if ($db{noindex}) { push @{$summary{Database}}, "[*] There are " . scalar (keys %{$db{noindex}}) . " tables without an index.\n"; }
        if ($db{excessindex}) { push @{$summary{Database}}, "[*] There are " . scalar (keys %{$db{excessindex}}) . " tables with excessive indexes.\n"; }
        if (short($stats{Slow_queries} / $stats{Uptime}) >= 1) { 
		push @{$summary{Database}}, "[*] The server is averaging " . short($stats{Slow_queries} / $stats{Uptime}) . " slow queries per second.\n"
		. "    Enable the slow_query_log to identify the cause.\n"; 
	}
        if (int(($stats{Select_range_check} + $stats{Select_full_join}) / ($stats{Uptime} / 86400)) >= 5000) { 
		push @{$summary{Database}}, "[*] There are a high number of joins without an index.\n"
		. "    Enable 'log_queries_not_using_indexes' to identify them.\n"; 
	}
        if (($vars{'query_cache_type'} =~  /^(ON|DEMAND|1|2)$/ ) and (not defined $db{tables}{MyISAM})) { push @{$summary{Database}}, "[*] The query_cache is enabled, but no MyISAM tables found.\n"; }
        if ($db{innodb_buffer_total} <= $db{BufferSize}) { 
		push @{$summary{Database}}, "[*] The innodb_buffer_pool_size (" . short($db{innodb_buffer_total}) . ") is smaller than the InnoDB data (" . short($db{BufferSize}) . ").\n";
	}

	if ($stats{Innodb_deadlocks} >= 10) {
		push @{$summary{Database}}, "[*] There have been $stats{Innodb_deadlocks} InnoDB deadlocks. Enable innodb_print_all_deadlocks to log them.\n";
	}
	if ($stats{Innodb_log_waits} > 0) {
		push @{$summary{Database}}, "[*] There have been $stats{Innodb_log_waits} innodb_log_waits. Consider increasing the innodb_log_buffer_size.\n";
	}
        if (defined $db{replication}{Slave_IO_Running} && $db{replication}{Slave_IO_Running} =~ /No/)   {
                push @{$summary{Database}}, "[*] Replication has stopped.\n"
                . "    Slave_IO_Running: $db{replication}{Slave_IO_Running}\n"
                . "    Error Number: $db{replication}{Last_IO_Errno}\n"
                . "    Error Message:  $db{replication}{Last_IO_Error}\n";
        }
        if (defined $db{replication}{Slave_SQL_Running} && $db{replication}{Slave_SQL_Running} =~ /No/) {
                push @{$summary{Database}}, "[*] Replication has stopped.\n"
                . "    Slave_SQL_Running: $db{replication}{Slave_SQL_Running}\n"
                . "    Error Number: $db{replication}{Last_SQL_Errno}\n"
                . "    Error Message:  $db{replication}{Last_SQL_Error}\n";
        }
        if (defined $db{replication}{Seconds_Behind_Master} && $db{replication}{Seconds_Behind_Master} >= 1000) {
                push @{$summary{Database}}, "[*] The slave is out of sync with the master.\n"
		. "    Seconds_Behind_Master: $db{replication}{Seconds_Behind_Master}\n";
        }
        my @usersec = ("useranon", "usernopasswd", "usernohost");
        my %replace = (
                "useranon" => "Anonymous user USER has SUPER privileges.",
                "usernopasswd" => "User USER has SUPER privileges but no password.",
                "usernohost" => "User USER has SUPER privileges but no host restrictions.",
        );
        foreach my $type(@usersec) {
                if ($db{$type}) {
                        foreach my $key (keys %{$db{$type}}) {
                                if (@{$db{$type}{$key}}[0] =~ /Y/) {
                                        (my $bad = $type ) =~ s/(useranon|usernopasswd|usernohost)/$replace{$1}/g;
                                        $bad =~ s/USER/$key/g;
                                        push @{$summary{Security}}, "[*] $bad\n";
                                }
                        }
                }
        }
}

sub print_summary {
# System Summary
	print "\n\n________________________ [CogecoPeer1 DBA " . ($opt{review} ? "Report" : "Summary")  . "] ________________________\n\n";
	print "Version: $version\n";
	print "Date: $sys{Date}\n";
	print "Hostname: $sys{Hostname}\n";
        print "IP addresses: ";
        foreach(@{$sys{IPAddresses}}) { print "$_  "; }
        print "\n";
	print "System: $sys{OSVersion}\n";
	print "MySQL: $vars{version}\n";
	print "System uptime: $sys{SystemUptime}\n";
	print "MySQL uptime: $sys{MySQLUptime}\n";
	print "Queries: " . short(($stats{Questions}) / $stats{'Uptime'}) . " per second.\n";

# Summary 
	my @items = ("CPU", "Memory", "Disk", "System", "Database", "Security",);
	foreach my $item(@items) {
		print "\n$item:\n";
		unless ($summary{$item}) { print "No issues found.\n"; next; }
		foreach (@{$summary{$item}}) { print "$_" };
	}
	print "\n\n________________________ [CogecoPeer1 DBA " . ($opt{review} ? "Report" : "Summary")  . "] ________________________\n\n";
}

sub print_report {
# CPU usage
        print "\n[CPU Info]\n";
        print "Model: $cpu{ModelName} (x$cpu{Sockets})\nCores: $cpu{TotalCores}\nThreads: $cpu{TotalThreads}\n";
        print "$cpu{TotalSarLogs} day average load: $cpu{LoadAve}\n";

# Memory usage
	print "\n[Memory Usage]\n";
	print "Total memory: $mem{MemTotal} \nFree memory: $mem{MemFree} ($mem{MemFreePerc}%)\nCached: $mem{Cached} \n";
	print "Total swap: $mem{SwapTotal} \nFree swap: $mem{SwapFree} ($mem{SwapFreePerc}%)\n";
	print "MySQL max configured memory: $mem{MySQLMaxConfigured} ($mem{MySQLUsedPerc}%)\n";
	print "MySQL max used memory: $mem{MySQLMaxUsed}\n";
	print "Base memory: $mem{MySQLBase} | Per Connection: $mem{MySQLPerConnection} | Max Connections: $vars{max_connections} | Max used Connections: $stats{Max_used_connections}\n\n";

# Disk usage
        my @disk_alerts;
        print "\n[Disk Usage]\n";
	printf $f{disk}, "Size","Used","Avail","Use%","Mounted on";
        foreach my $filesystem (keys %fsinfo) {
                printf $f{disk}, $fsinfo{$filesystem}{TotalSize},$fsinfo{$filesystem}{Used},$fsinfo{$filesystem}{Available},$fsinfo{$filesystem}{PercentUsed},$filesystem;
        }
        print "\n";

# System Updates
	print "\n[System Updates]\n";
	print "Last update time: $sys{LastUpdateTime}\n";
	print "Last reboot time: $sys{TimeOfReboot}\n";
	print "Kernel in use: $sys{KernelInUse}\n";
	print "Kernel update: $sys{LastKernelVersion}\n";

# Backups
	print "\n[Backups]\n";
	if ($sys{BackupCronFound}) { 
		foreach(@{$sys{BackupCron}}) { print "Crontab [Y] - $_"; }
	} else {
		print "Crontab [N] - No scheduled backup was detected.\n";
		$sys{BackupWarn} = "1";
	}
	if ($sys{BackupDirFound}) {
		foreach(@{$sys{BackupDir}}) { print "Backup directory [Y] - $_\n"; } 
	} else {
		print "Backup directory [N] - No backup directory was found.\n\n";
	}
	if ($sys{TivoliInstalled}) {
		print "Tivoli installed? [Y] - /opt/tivoli\n"
	} else {
		print "Tivoli installed? [N] - Tivoli backup was not detected on this server.\n\n";
	}

# Databases
	print "\n[Databases]\n";
	printf $f{db}, "Database Name", "Size (MB)", "MyISAM", "InnoDB", "Views", "Total";
	foreach my $key ( sort { $db{database}{$b}[0] <=> $db{database}{$a}[0] } keys %{$db{database}} ) {
		printf $f{db}, $key, @{$db{database}{$key}};
	}

# Tables
	print "\n[Tables]\n";
	printf $f{table}, "Engine", "  Tables", "Rows", "Data", "Index", "Size", "idxfrac";
	foreach my $key ( sort { $db{tables}{$b}[0] <=> $db{tables}{$a}[0] } keys %{$db{tables}} ) {
		printf $f{table}, $key, @{$db{tables}{$key}};
	}

# Tables - fragmentation / unique keys / indexing
	if ($db{frag}) {
		print "\n[Fragmented Tables]\n";
		printf $f{frag}, "Database", "Table", "Free (MB)", "Engine";
		my $count = 1;
		foreach my $key (sort { $db{frag}{$b}[1] <=> $db{frag}{$a}[1] } keys %{$db{frag}}) {
			my $dbname = shift @{$db{frag}{$key}};
	                printf $f{frag}, $dbname, $key, @{$db{frag}{$key}} if ($count <= $sys{count});
			$count++;
		}
		if ($sys{count} < scalar (keys %{$db{frag}})) { print "Showing a maximum of $sys{count}/" . scalar (keys %{$db{frag}}) . " tables. Use the '-showall' option to print all tables.\n"; }
	}
	if ($db{ukeys}) {
		print "\n[Missing Primary / Unique Keys]\n";
		printf $f{keys}, "Database", "Table";
		my $count = 1;
		foreach my $key (keys %{$db{ukeys}}) {
			my $dbname = shift @{$db{ukeys}{$key}};
			printf $f{keys}, $dbname, $key, @{$db{ukeys}{$key}}  if ($count <= $sys{count});
			$count++;
		}
		if ($sys{count} < scalar (keys %{$db{ukeys}})) { print "Showing a maximum of $sys{count}/" . scalar (keys %{$db{ukeys}}) . " tables. Use the '-showall' option to print all tables.\n"; }
	}

	if ($db{noindex}) {
		print "\n[No Indexes]\n";
		printf $f{noidx}, "Database", "Table", "Collation", "Engine", "Rows";	
		my $count = 1;
		foreach my $key (keys %{$db{noindex}}) {
			my $dbname = shift @{$db{noindex}{$key}};
			printf $f{noidx}, $dbname, $key, @{$db{noindex}{$key}} if ($count <= $sys{count});		
			$count++;
		}
		if ($sys{count} < scalar (keys %{$db{noindex}})) { print "Showing a maximum of $sys{count}/" . scalar (keys %{$db{noindex}}) . " tables. Use the '-showall' option to print all tables.\n"; }
	}
	if ($db{excessindex}) {
		print "\n[Excess Indexes]\n";
		printf $f{xsidx}, "Database", "Table", "Indexes";
		my $count = 1;
		foreach my $key (keys %{$db{excessindex}}) {
			my $dbname = shift @{$db{excessindex}{$key}};
			printf $f{xsidx}, $dbname, $key, @{$db{excessindex}{$key}} if ($count <= $sys{count});
			$count++;
		}
                if ($sys{count} < scalar (keys %{$db{excessindex}})) { print "Showing a maximum of $sys{count}/" . scalar (keys %{$db{excessindex}}) . " tables. Use the '-showall' option to print all tables.\n"; }
	}

# Table Cache
	print "\n[Table Cache]\n";
	print "Open: $stats{'Open_tables'} of $vars{'table_cache'} Cached: " . percent($stats{'Open_tables'}, $vars{'table_cache'}) . "% \n";
	print "Opened: " . short($stats{'Opened_tables'}) . " (" . short($stats{'Opened_tables'} / $stats{'Uptime'}, 0, 1) . "/s)\n";

# Temp tables			
        print "\n[Temporary Tables]\n";
        print "Total: $stats{Created_tmp_tables}\n";
        print "Disk: $stats{Created_tmp_disk_tables} (" . percent($stats{Created_tmp_disk_tables}, $stats{Created_tmp_tables}) . "%)\n";
        print "Tmpdir: $vars{tmpdir}\n";

# Connections
        print "\n[Connections]\n";
        print "Max used: $stats{Max_used_connections} of $vars{max_connections} (" . percent($stats{Max_used_connections},$vars{max_connections}) . "%)\n";
        print "Total: $stats{Connections}\n";

# Thread Cache Size
        print "\n[Thread Cache Size]\n";
        print "Current thread_cache_size: $vars{thread_cache_size}\n";
        print "Cache usage: " . percent($stats{Threads_created}, $stats{Connections}) . "%\n";
        print "Optimal thread_cache_size: $db{Threads}\n";

# Slow queries
        print "\n[Slow queries]\n";
        print "slow_query_log enabled: $vars{'slow_query_log'}\n";
        print "slow_query_log: $vars{'slow_query_log_file'}\n";
        print "Slow queries: " . short($stats{Slow_queries}) . " (" . short($stats{Slow_queries} / $stats{Uptime}) . "/s) (" . percent($stats{Slow_queries}, $stats{Questions}) . "%)\n";

# Joins & table scans
        print "\n[Table Scans]\n";
        print "No index: " . ($stats{Select_range_check} + $stats{Select_full_join}) . " (Daily - " . int(($stats{Select_range_check} + $stats{Select_full_join}) / ($stats{Uptime} / 86400)) .")\n";
        print "Select_scan: $stats{'Select_scan'}\n";
        print "Sort_scan: $stats{'Sort_scan'}\n";
        print "Select_full_join: $stats{'Select_full_join'}\n";
        print "Select_full_range_join: $stats{'Select_full_range_join'}\n";
        print "Full table scans: " . short(($stats{'Handler_read_rnd_next'} + $stats{'Handler_read_rnd'}) / ($stats{'Handler_read_rnd_next'} + $stats{'Handler_read_rnd'} + $stats{'Handler_read_first'} + $stats{'Handler_read_next'} + $stats{'Handler_read_key'} + $stats{'Handler_read_prev'})) . "%\n";

# table locks
        print "\n[Table Locks]\n";
        print "Immediate: $stats{'Table_locks_immediate'}\n";
        print "Waited: $stats{'Table_locks_waited'}\n";	
#
# # MyISAM
# query cache

	print "\n[Query Cache]\n";
        print "Type: $vars{'query_cache_type'}\n";
        if ( $vars{'query_cache_type'} =~  /^(ON|DEMAND|1|2)$/ ) {
		print "Memory usage: " . short($vars{query_cache_size} - $stats{Qcache_free_memory},1) . " of " . short($vars{query_cache_size},1) . " (" . percent(($vars{query_cache_size} - $stats{Qcache_free_memory}), $vars{query_cache_size}) . "%)\n"; 
		print "Hits per sec: " . short($stats{'Qcache_hits'} / $stats{Uptime}) . "\n";		
                if ($stats{Qcache_hits}) {print "Hit rate: " . short(($stats{'Qcache_hits'} / ($stats{'Qcache_hits'} + $stats{'Qcache_inserts'} + $stats{'Qcache_not_cached'})) * 100) . "%\n"; }
                print "\n[Qcache Stats]\n";
                print "SELECT: $db{select}\nINSERT: $db{insert}\nREPLACE: $db{replace}\nUPDATE: $db{update}\nDELETE: $db{delete}\n";
                print "Lowmem prunes: $stats{'Qcache_lowmem_prunes'}\nNot Cached: $stats{'Qcache_not_cached'}\nQueries in Cache: $stats{'Qcache_queries_in_cache'}\nTotal Blocks: $stats{'Qcache_total_blocks'}\n";
	}

# key buffer
	print "\n[Key Buffer]\n";
	print "Used: " . short(($stats{Key_blocks_used} * $db{key_cache_block_size}), 1) . " of " . short($vars{key_buffer_size}, 1) . " (" . percent(($stats{Key_blocks_used} * $db{key_cache_block_size}), $vars{key_buffer_size}) . "%)\n";
	print "Write Hit: $db{key_write_ratio}%\nRead Hit: $db{key_read_ratio}%\n";

#
# # InnoDB
#
	if (defined $db{tables}{InnoDB}) {
# buffer_pool
		print "\n[InnoDB Buffer Pool]\n";
		print "Instances: $vars{'innodb_buffer_pool_instances'}\n";
		print "Usage: " . short($db{innodb_buffer_used}) . " of " . short($db{innodb_buffer_total}) . " (" . percent($db{innodb_buffer_used}, $db{innodb_buffer_total}) . "%)\n";
		print "Read hit: $db{innodb_buffer_hits}%\n";
		if ($db{innodb_buffer_total} <= $db{BufferSize}) { print "Minimum recommended size: " . short($db{BufferSize}) . "\n"; }

#[InnoDB Locks]
		print "\n[InnoDB Locks]\n";
       		print "Waits: $stats{Innodb_row_lock_waits} (" . short($stats{Innodb_row_lock_waits} / $stats{Uptime}, 0, 1) ."/s)\n";
       		print "Current: $stats{Innodb_row_lock_current_waits}\n";
       		print "Average: $stats{Innodb_row_lock_time_avg}\n";
       		print "Max: $stats{Innodb_row_lock_time_max}\n";
       	        print "Deadlocks: $stats{Innodb_deadlocks}\n";

#[InnoDB Stats]
		print "\n[InnoDB Stats]\n";
		print "Data:\n";
		print " Reads: " . $stats{Innodb_data_reads} . " (" . short($stats{Innodb_data_reads} / $stats{Uptime}, 0, 1) . "/s)\n";
		print " Writes: " . $stats{Innodb_data_writes} . " (" . short($stats{Innodb_data_writes} / $stats{Uptime}, 0, 1) . "/s)\n";
		print "Rows:\n";
		print " Deleted: " . $stats{Innodb_rows_deleted} . " (" . short($stats{Innodb_rows_deleted} / $stats{Uptime}, 0, 1) . "/s)\n";
		print " Inserted: " . $stats{Innodb_rows_inserted} . " (" . short($stats{Innodb_rows_inserted} / $stats{Uptime}, 0, 1) . "/s\n";
		print " Read: " . $stats{Innodb_rows_read} . " (" . short($stats{Innodb_rows_read} / $stats{Uptime}, 0, 1) . "/s)\n";
		print " Updated: " . $stats{Innodb_rows_updated} . " (" . short($stats{Innodb_rows_updated} / $stats{Uptime}, 0, 1) . "/s)\n";

#[InnoDB Settings]
		print "\n[InnoDB Settings]\n";
		print "innodb_file_per_table: $vars{innodb_file_per_table}\n";
		print "innodb_flush_log_at_trx_commit: $vars{innodb_flush_log_at_trx_commit}\n";
		print "inoodb_flush_method: $vars{innodb_flush_method}\n";
		if ( $stats{Innodb_log_waits} > 0 ) {
			print "Innodb_log_waits: $stats{Innodb_log_waits}\n";
		}
	}

#[MySQL Roles]
	if (defined $db{replication}{Slave_IO_Running}) {
	        print "\n[Replication]\n";
	        print "Master_Host: $db{replication}{Master_Host}\n";
        	print "Slave_IO_Running: $db{replication}{Slave_IO_Running}\n";
	        print "Slave_SQL_Running: $db{replication}{Slave_SQL_Running}\n";
	        if (defined $db{replication}{Seconds_Behind_Master}) {
	                print "Seconds_Behind_Master: $db{replication}{Seconds_Behind_Master}\n";
	        }
	        print "Slave read-only? $vars{read_only}\n";
	        print "Bin-log format: $vars{binlog_format}\n";
	}

#[Anonymous user accounts]
        if (defined $db{useranon}) {
                print "\n[Anonymous user accounts]\n";
                foreach my $key (keys %{$db{useranon}}) {
                        print "$key  " . ($db{useranon}{$key}[0] =~ /Y/ ? "\(SuperUser\)" : "")  . "\n";
                }
        }

#[Accounts without passwords]
        if (defined $db{usernopasswd}) {
                print "\n[Accounts with no password]\n";
                foreach my $key (keys %{$db{usernopasswd}}) {
                        print "$key  " . ($db{usernopasswd}{$key}[0] =~ /Y/ ? "\(SuperUser\)" : "")  . "\n";
                }
        }

#[Users without host restrictions]
        if (defined $db{usernohost}) {
                print "\n[Accounts with no host restriction]\n";
                foreach my $key (keys %{$db{usernohost}}) {
                        print "$key  " . ($db{usernohost}{$key}[0] =~ /Y/ ? "\(SuperUser\)" : "")  . "\n";
                }
        }
}



if ($opt{help}) { usage(); }
if (defined $opt{'update'}) { update(); }
$mycnf{'user'} = $opt{'username'} if (defined $opt{'username'});
$mycnf{'pass'} = $opt{'password'} if (defined $opt{'password'});
$mycnf{'host'} = ($opt{'host'}) ? $opt{'host'} : '127.0.0.1';
if (defined $mycnf{'user'} and not $mycnf{'pass'}) {
	print STDERR "Please enter the MySQL password for $mycnf{'user'}: \n";
        system("stty -echo > /dev/null 2>&1");
        my $passwd = <>;
        system("stty echo > /dev/null 2>&1");
        chomp ($passwd);
        $mycnf{'pass'} = $passwd;
}
get_mycnf() unless (defined $mycnf{'user'} and $mycnf{'pass'});
connect_db();
get_stats();
get_vars();
if ($opt{query}) { search(); }
get_cpu_usage();
get_memory_usage();
get_disk_usage();
get_system_info();
get_backup_info();
run_queries();
set_format();
if ($opt{debug}) { debug(); }
prep_summary();
print_summary();
if ($opt{review}) { 
	if ($opt{showall}) { 
		$sys{count} = $db{TableCount}; 
	} else { 
		$sys{count} = '5'; 
	}
	print_report(); 
}
